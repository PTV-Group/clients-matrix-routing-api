/* tslint:disable */
/* eslint-disable */
/**
 * Matrix Routing
 * With the Matrix Routing service you can compute distances and travel times between a set of origins and destinations.
 *
 * The version of the OpenAPI document: 1.8
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorResponse,
  ListOfLocations,
  Locations,
  MatrixIdentifier,
  MatrixResponse,
  Options,
  Results,
  RouteIdentifier,
  StatusResponse,
} from '../models/index';
import {
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    ListOfLocationsFromJSON,
    ListOfLocationsToJSON,
    LocationsFromJSON,
    LocationsToJSON,
    MatrixIdentifierFromJSON,
    MatrixIdentifierToJSON,
    MatrixResponseFromJSON,
    MatrixResponseToJSON,
    OptionsFromJSON,
    OptionsToJSON,
    ResultsFromJSON,
    ResultsToJSON,
    RouteIdentifierFromJSON,
    RouteIdentifierToJSON,
    StatusResponseFromJSON,
    StatusResponseToJSON,
} from '../models/index';

export interface CalculateMatrixRequest {
    locations: Locations;
    profile?: string;
    results?: Array<Results>;
    options?: Options;
}

export interface CancelMatrixCalculationRequest {
    id: string;
}

export interface GetMatrixRequest {
    id: string;
}

export interface GetRouteIdRequest {
    listOfLocations: ListOfLocations;
    profile?: string;
}

export interface GetStatusRequest {
    id: string;
}

export interface StartMatrixCalculationRequest {
    locations: Locations;
    profile?: string;
    results?: Array<Results>;
    options?: Options;
}

/**
 * 
 */
export class MatricesApi extends runtime.BaseAPI {

    /**
     * Creates a matrix by calculating distances and travel times between given origins and destinations. \\ The request is rejected if the number of origins or the number of destinations is greater than 10,000 or the number of relations (number of origins * number of destinations) is greater than 250,000.\\ The `TOLL_COSTS` result option is not allowed with this operation because toll cost calculation takes much longer. \\ Gzip-encoded content is supported in the request body and returned in the response if accepted by the client.\\ Please use the startMatrixCalculation operation * if you want to get toll costs, * for time-dependent matrices, * for more origins, destinations and relations (see also the [FAQ](../../help/faq-help) for details regarding limits).
     */
    async calculateMatrixRaw(requestParameters: CalculateMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MatrixResponse>> {
        if (requestParameters['locations'] == null) {
            throw new runtime.RequiredError(
                'locations',
                'Required parameter "locations" was null or undefined when calling calculateMatrix().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        if (requestParameters['results'] != null) {
            queryParameters['results'] = requestParameters['results']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['options'] != null) {
            queryParameters['options'] = requestParameters['options'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationsToJSON(requestParameters['locations']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MatrixResponseFromJSON(jsonValue));
    }

    /**
     * Creates a matrix by calculating distances and travel times between given origins and destinations. \\ The request is rejected if the number of origins or the number of destinations is greater than 10,000 or the number of relations (number of origins * number of destinations) is greater than 250,000.\\ The `TOLL_COSTS` result option is not allowed with this operation because toll cost calculation takes much longer. \\ Gzip-encoded content is supported in the request body and returned in the response if accepted by the client.\\ Please use the startMatrixCalculation operation * if you want to get toll costs, * for time-dependent matrices, * for more origins, destinations and relations (see also the [FAQ](../../help/faq-help) for details regarding limits).
     */
    async calculateMatrix(requestParameters: CalculateMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MatrixResponse> {
        const response = await this.calculateMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancels a matrix calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
     */
    async cancelMatrixCalculationRaw(requestParameters: CancelMatrixCalculationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling cancelMatrixCalculation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancels a matrix calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
     */
    async cancelMatrixCalculation(requestParameters: CancelMatrixCalculationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cancelMatrixCalculationRaw(requestParameters, initOverrides);
    }

    /**
     * Requests the results of a matrix calculation operation. Gzip-encoded content is returned in the response if accepted by the client.
     */
    async getMatrixRaw(requestParameters: GetMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MatrixResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getMatrix().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MatrixResponseFromJSON(jsonValue));
    }

    /**
     * Requests the results of a matrix calculation operation. Gzip-encoded content is returned in the response if accepted by the client.
     */
    async getMatrix(requestParameters: GetMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MatrixResponse> {
        const response = await this.getMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a routeId representing a route with the specified list of locations. The route is calculated using the same routing algorithm as the calculateMatrix and startMatrixCalculation operations.\\ The returned **routeId** can be then used in combination with the Routing API to retrieve further details about the route, e.g polyline.\\ **This operation is in an experimental state and may change at any time.**
     */
    async getRouteIdRaw(requestParameters: GetRouteIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RouteIdentifier>> {
        if (requestParameters['listOfLocations'] == null) {
            throw new runtime.RequiredError(
                'listOfLocations',
                'Required parameter "listOfLocations" was null or undefined when calling getRouteId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/route`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ListOfLocationsToJSON(requestParameters['listOfLocations']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteIdentifierFromJSON(jsonValue));
    }

    /**
     * Returns a routeId representing a route with the specified list of locations. The route is calculated using the same routing algorithm as the calculateMatrix and startMatrixCalculation operations.\\ The returned **routeId** can be then used in combination with the Routing API to retrieve further details about the route, e.g polyline.\\ **This operation is in an experimental state and may change at any time.**
     */
    async getRouteId(requestParameters: GetRouteIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RouteIdentifier> {
        const response = await this.getRouteIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Requests the status of a matrix calculation.
     */
    async getStatusRaw(requestParameters: GetStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StatusResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/status/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusResponseFromJSON(jsonValue));
    }

    /**
     * Requests the status of a matrix calculation.
     */
    async getStatus(requestParameters: GetStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StatusResponse> {
        const response = await this.getStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a matrix asynchronously by calculating distances, travel times and toll costs between given origins and destinations.\\ The request is rejected if the number of relations (number of origins * number of destinations) is greater than 4,000,000 (see also the [FAQ](../../help/faq-help) for details regarding limits).\\ Please note that toll cost and time-dependent calculations significantly increase the operation runtime.\\ Gzip-encoded content is supported in the request body.
     */
    async startMatrixCalculationRaw(requestParameters: StartMatrixCalculationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MatrixIdentifier>> {
        if (requestParameters['locations'] == null) {
            throw new runtime.RequiredError(
                'locations',
                'Required parameter "locations" was null or undefined when calling startMatrixCalculation().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        if (requestParameters['results'] != null) {
            queryParameters['results'] = requestParameters['results']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['options'] != null) {
            queryParameters['options'] = requestParameters['options'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/async`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationsToJSON(requestParameters['locations']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MatrixIdentifierFromJSON(jsonValue));
    }

    /**
     * Creates a matrix asynchronously by calculating distances, travel times and toll costs between given origins and destinations.\\ The request is rejected if the number of relations (number of origins * number of destinations) is greater than 4,000,000 (see also the [FAQ](../../help/faq-help) for details regarding limits).\\ Please note that toll cost and time-dependent calculations significantly increase the operation runtime.\\ Gzip-encoded content is supported in the request body.
     */
    async startMatrixCalculation(requestParameters: StartMatrixCalculationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MatrixIdentifier> {
        const response = await this.startMatrixCalculationRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
