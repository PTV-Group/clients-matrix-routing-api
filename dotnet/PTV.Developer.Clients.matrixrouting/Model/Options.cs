/*
 * Matrix Routing
 *
 * With the Matrix Routing service you can compute distances and travel times between a set of origins and destinations.
 *
 * The version of the OpenAPI document: 1.4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.matrixrouting.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.matrixrouting.Model
{
    /// <summary>
    /// Options
    /// </summary>
    [DataContract(Name = "Options")]
    public partial class Options : IEquatable<Options>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets TrafficMode
        /// </summary>
        [DataMember(Name = "trafficMode", EmitDefaultValue = false)]
        public TrafficMode? TrafficMode { get; set; }
        /// <summary>
        /// Gets or Sets ResultFormat
        /// </summary>
        [DataMember(Name = "resultFormat", EmitDefaultValue = false)]
        public ResultFormat? ResultFormat { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Options" /> class.
        /// </summary>
        /// <param name="currency">Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**..</param>
        /// <param name="startTime">Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an exception is thrown and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./time-dependent-matrix) for more information on the relevance of date and time..</param>
        /// <param name="duration">Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set. (default to 0).</param>
        /// <param name="trafficMode">trafficMode.</param>
        /// <param name="resultFormat">resultFormat.</param>
        public Options(string currency = default(string), DateTimeOffset? startTime = default(DateTimeOffset?), int duration = 0, TrafficMode? trafficMode = default(TrafficMode?), ResultFormat? resultFormat = default(ResultFormat?))
        {
            this.Currency = currency;
            this.StartTime = startTime;
            this.Duration = duration;
            this.TrafficMode = trafficMode;
            this.ResultFormat = resultFormat;
        }

        /// <summary>
        /// Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**.
        /// </summary>
        /// <value>Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**.</value>
        [DataMember(Name = "currency", EmitDefaultValue = true)]
        public string Currency { get; set; }

        /// <summary>
        /// Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an exception is thrown and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./time-dependent-matrix) for more information on the relevance of date and time.
        /// </summary>
        /// <value>Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an exception is thrown and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./time-dependent-matrix) for more information on the relevance of date and time.</value>
        [DataMember(Name = "startTime", EmitDefaultValue = true)]
        public DateTimeOffset? StartTime { get; set; }

        /// <summary>
        /// Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set.
        /// </summary>
        /// <value>Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set.</value>
        [DataMember(Name = "duration", EmitDefaultValue = false)]
        public int Duration { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Options {\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  StartTime: ").Append(StartTime).Append("\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  TrafficMode: ").Append(TrafficMode).Append("\n");
            sb.Append("  ResultFormat: ").Append(ResultFormat).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Options);
        }

        /// <summary>
        /// Returns true if Options instances are equal
        /// </summary>
        /// <param name="input">Instance of Options to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Options input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Currency == input.Currency ||
                    (this.Currency != null &&
                    this.Currency.Equals(input.Currency))
                ) && 
                (
                    this.StartTime == input.StartTime ||
                    (this.StartTime != null &&
                    this.StartTime.Equals(input.StartTime))
                ) && 
                (
                    this.Duration == input.Duration ||
                    this.Duration.Equals(input.Duration)
                ) && 
                (
                    this.TrafficMode == input.TrafficMode ||
                    this.TrafficMode.Equals(input.TrafficMode)
                ) && 
                (
                    this.ResultFormat == input.ResultFormat ||
                    this.ResultFormat.Equals(input.ResultFormat)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Currency != null)
                    hashCode = hashCode * 59 + this.Currency.GetHashCode();
                if (this.StartTime != null)
                    hashCode = hashCode * 59 + this.StartTime.GetHashCode();
                hashCode = hashCode * 59 + this.Duration.GetHashCode();
                hashCode = hashCode * 59 + this.TrafficMode.GetHashCode();
                hashCode = hashCode * 59 + this.ResultFormat.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Currency (string) pattern
            Regex regexCurrency = new Regex(@"[A-Z]{3}", RegexOptions.CultureInvariant);
            if (false == regexCurrency.Match(this.Currency).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Currency, must match a pattern of " + regexCurrency, new [] { "Currency" });
            }

            // Duration (int) maximum
            if(this.Duration > (int)86400)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Duration, must be a value less than or equal to 86400.", new [] { "Duration" });
            }

            // Duration (int) minimum
            if(this.Duration < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Duration, must be a value greater than or equal to 0.", new [] { "Duration" });
            }

            yield break;
        }
    }

}
