/*
 * Matrix Routing
 *
 * With the Matrix Routing service you can compute distances and travel times between a set of origins and destinations.
 *
 * The version of the OpenAPI document: 1.7
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.matrixrouting.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.matrixrouting.Model
{
    /// <summary>
    /// Options
    /// </summary>
    [DataContract(Name = "Options")]
    public partial class Options : IValidatableObject
    {

        /// <summary>
        /// Gets or Sets TrafficMode
        /// </summary>
        [DataMember(Name = "trafficMode", EmitDefaultValue = true)]
        public TrafficMode? TrafficMode { get; set; }

        /// <summary>
        /// Gets or Sets ResultFormat
        /// </summary>
        [DataMember(Name = "resultFormat", EmitDefaultValue = true)]
        public ResultFormat? ResultFormat { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Options" /> class.
        /// </summary>
        /// <param name="currency">Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**..</param>
        /// <param name="startTime">Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **tollTime**. If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./concepts/time-dependent-matrix) for more information on the relevance of date and time. **Only available for startMatrixCalculation operation.**.</param>
        /// <param name="tollTime">Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with **startTime**. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/toll-matrix-calculation) for more information on the relevance of date and time. **Only available for startMatrixCalculation operation.**.</param>
        /// <param name="duration">Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set. **Only available for startMatrixCalculation operation.** (default to 0).</param>
        /// <param name="trafficMode">trafficMode.</param>
        /// <param name="detourFactor">Defines the average detour an actual route on the road requires, compared to the direct distance. This factor is used to estimate by direct distance a relation that could not be calculated using the road network. (default to 1.38D).</param>
        /// <param name="averageSpeed">Defines the average speed of the vehicle. This parameter is used to calculate the travel time for a relation that could not be calculated using the road network. (default to 60D).</param>
        /// <param name="resultFormat">resultFormat.</param>
        public Options(string currency = default(string), DateTimeOffset? startTime = default(DateTimeOffset?), DateTimeOffset? tollTime = default(DateTimeOffset?), int? duration = 0, TrafficMode? trafficMode = default(TrafficMode?), double? detourFactor = 1.38D, double? averageSpeed = 60D, ResultFormat? resultFormat = default(ResultFormat?))
        {
            this.Currency = currency;
            this.StartTime = startTime;
            this.TollTime = tollTime;
            // use default value if no "duration" provided
            this.Duration = duration ?? 0;
            this.TrafficMode = trafficMode;
            // use default value if no "detourFactor" provided
            this.DetourFactor = detourFactor ?? 1.38D;
            // use default value if no "averageSpeed" provided
            this.AverageSpeed = averageSpeed ?? 60D;
            this.ResultFormat = resultFormat;
        }

        /// <summary>
        /// Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**.
        /// </summary>
        /// <value>Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**.</value>
        [DataMember(Name = "currency", EmitDefaultValue = true)]
        public string Currency { get; set; }

        /// <summary>
        /// Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **tollTime**. If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./concepts/time-dependent-matrix) for more information on the relevance of date and time. **Only available for startMatrixCalculation operation.**
        /// </summary>
        /// <value>Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **tollTime**. If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./concepts/time-dependent-matrix) for more information on the relevance of date and time. **Only available for startMatrixCalculation operation.**</value>
        /// <example>2020-12-04T06:00Z</example>
        [DataMember(Name = "startTime", EmitDefaultValue = true)]
        public DateTimeOffset? StartTime { get; set; }

        /// <summary>
        /// Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with **startTime**. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/toll-matrix-calculation) for more information on the relevance of date and time. **Only available for startMatrixCalculation operation.**
        /// </summary>
        /// <value>Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with **startTime**. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/toll-matrix-calculation) for more information on the relevance of date and time. **Only available for startMatrixCalculation operation.**</value>
        [DataMember(Name = "tollTime", EmitDefaultValue = true)]
        public DateTimeOffset? TollTime { get; set; }

        /// <summary>
        /// Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set. **Only available for startMatrixCalculation operation.**
        /// </summary>
        /// <value>Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set. **Only available for startMatrixCalculation operation.**</value>
        [DataMember(Name = "duration", EmitDefaultValue = true)]
        public int? Duration { get; set; }

        /// <summary>
        /// Defines the average detour an actual route on the road requires, compared to the direct distance. This factor is used to estimate by direct distance a relation that could not be calculated using the road network.
        /// </summary>
        /// <value>Defines the average detour an actual route on the road requires, compared to the direct distance. This factor is used to estimate by direct distance a relation that could not be calculated using the road network.</value>
        [DataMember(Name = "detourFactor", EmitDefaultValue = true)]
        public double? DetourFactor { get; set; }

        /// <summary>
        /// Defines the average speed of the vehicle. This parameter is used to calculate the travel time for a relation that could not be calculated using the road network.
        /// </summary>
        /// <value>Defines the average speed of the vehicle. This parameter is used to calculate the travel time for a relation that could not be calculated using the road network.</value>
        [DataMember(Name = "averageSpeed", EmitDefaultValue = true)]
        public double? AverageSpeed { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Options {\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  StartTime: ").Append(StartTime).Append("\n");
            sb.Append("  TollTime: ").Append(TollTime).Append("\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  TrafficMode: ").Append(TrafficMode).Append("\n");
            sb.Append("  DetourFactor: ").Append(DetourFactor).Append("\n");
            sb.Append("  AverageSpeed: ").Append(AverageSpeed).Append("\n");
            sb.Append("  ResultFormat: ").Append(ResultFormat).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.Currency != null) {
                // Currency (string) pattern
                Regex regexCurrency = new Regex(@"[A-Z]{3}", RegexOptions.CultureInvariant);
                if (!regexCurrency.Match(this.Currency).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Currency, must match a pattern of " + regexCurrency, new [] { "Currency" });
                }
            }

            // Duration (int?) maximum
            if (this.Duration > (int?)86400)
            {
                yield return new ValidationResult("Invalid value for Duration, must be a value less than or equal to 86400.", new [] { "Duration" });
            }

            // Duration (int?) minimum
            if (this.Duration < (int?)0)
            {
                yield return new ValidationResult("Invalid value for Duration, must be a value greater than or equal to 0.", new [] { "Duration" });
            }

            // DetourFactor (double?) minimum
            if (this.DetourFactor < (double?)1)
            {
                yield return new ValidationResult("Invalid value for DetourFactor, must be a value greater than or equal to 1.", new [] { "DetourFactor" });
            }

            // AverageSpeed (double?) minimum
            if (this.AverageSpeed < (double?)1)
            {
                yield return new ValidationResult("Invalid value for AverageSpeed, must be a value greater than or equal to 1.", new [] { "AverageSpeed" });
            }

            yield break;
        }
    }

}
