/*
 * Matrix Routing
 * With the Matrix Routing service you can compute distances and travel times between a set of origins and destinations.
 *
 * The version of the OpenAPI document: 1.8
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.matrixrouting.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.matrixrouting.model.ResultFormat;
import com.ptvgroup.developer.client.matrixrouting.model.TrafficMode;
import java.time.OffsetDateTime;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.ptvgroup.developer.client.matrixrouting.ApiClient;
/**
 * Options
 */
@JsonPropertyOrder({
  Options.JSON_PROPERTY_CURRENCY,
  Options.JSON_PROPERTY_START_TIME,
  Options.JSON_PROPERTY_TOLL_TIME,
  Options.JSON_PROPERTY_DURATION,
  Options.JSON_PROPERTY_TRAFFIC_MODE,
  Options.JSON_PROPERTY_DETOUR_FACTOR,
  Options.JSON_PROPERTY_AVERAGE_SPEED,
  Options.JSON_PROPERTY_RESULT_FORMAT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-10T13:06:20.919447521Z[Etc/UTC]", comments = "Generator version: 7.8.0")
public class Options {
  public static final String JSON_PROPERTY_CURRENCY = "currency";
  private String currency;

  public static final String JSON_PROPERTY_START_TIME = "startTime";
  private OffsetDateTime startTime;

  public static final String JSON_PROPERTY_TOLL_TIME = "tollTime";
  private OffsetDateTime tollTime;

  public static final String JSON_PROPERTY_DURATION = "duration";
  private Integer duration = 0;

  public static final String JSON_PROPERTY_TRAFFIC_MODE = "trafficMode";
  private TrafficMode trafficMode = TrafficMode.AVERAGE;

  public static final String JSON_PROPERTY_DETOUR_FACTOR = "detourFactor";
  private Double detourFactor = 1.38d;

  public static final String JSON_PROPERTY_AVERAGE_SPEED = "averageSpeed";
  private Double averageSpeed = 60d;

  public static final String JSON_PROPERTY_RESULT_FORMAT = "resultFormat";
  private ResultFormat resultFormat = ResultFormat.PLAIN;

  public Options() { 
  }

  public Options currency(String currency) {
    this.currency = currency;
    return this;
  }

  /**
   * Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**.
   * @return currency
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CURRENCY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getCurrency() {
    return currency;
  }


  @JsonProperty(JSON_PROPERTY_CURRENCY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public Options startTime(OffsetDateTime startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **tollTime**. If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./concepts/time-dependent-matrix) for more information on the relevance of date and time. **Only available for startMatrixCalculation operation.**
   * @return startTime
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_START_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public OffsetDateTime getStartTime() {
    return startTime;
  }


  @JsonProperty(JSON_PROPERTY_START_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStartTime(OffsetDateTime startTime) {
    this.startTime = startTime;
  }


  public Options tollTime(OffsetDateTime tollTime) {
    this.tollTime = tollTime;
    return this;
  }

  /**
   * Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with **startTime**. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/toll-matrix-calculation) for more information on the relevance of date and time. **Only available for startMatrixCalculation operation.**
   * @return tollTime
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TOLL_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public OffsetDateTime getTollTime() {
    return tollTime;
  }


  @JsonProperty(JSON_PROPERTY_TOLL_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTollTime(OffsetDateTime tollTime) {
    this.tollTime = tollTime;
  }


  public Options duration(Integer duration) {
    this.duration = duration;
    return this;
  }

  /**
   * Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set. **Only available for startMatrixCalculation operation.**
   * minimum: 0
   * maximum: 86400
   * @return duration
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DURATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Integer getDuration() {
    return duration;
  }


  @JsonProperty(JSON_PROPERTY_DURATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDuration(Integer duration) {
    this.duration = duration;
  }


  public Options trafficMode(TrafficMode trafficMode) {
    this.trafficMode = trafficMode;
    return this;
  }

  /**
   * Get trafficMode
   * @return trafficMode
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TRAFFIC_MODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public TrafficMode getTrafficMode() {
    return trafficMode;
  }


  @JsonProperty(JSON_PROPERTY_TRAFFIC_MODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTrafficMode(TrafficMode trafficMode) {
    this.trafficMode = trafficMode;
  }


  public Options detourFactor(Double detourFactor) {
    this.detourFactor = detourFactor;
    return this;
  }

  /**
   * Defines the average detour an actual route on the road requires, compared to the direct distance. This factor is used to estimate by direct distance a relation that could not be calculated using the road network.
   * minimum: 1
   * @return detourFactor
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DETOUR_FACTOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getDetourFactor() {
    return detourFactor;
  }


  @JsonProperty(JSON_PROPERTY_DETOUR_FACTOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDetourFactor(Double detourFactor) {
    this.detourFactor = detourFactor;
  }


  public Options averageSpeed(Double averageSpeed) {
    this.averageSpeed = averageSpeed;
    return this;
  }

  /**
   * Defines the average speed of the vehicle. This parameter is used to calculate the travel time for a relation that could not be calculated using the road network.
   * minimum: 1
   * @return averageSpeed
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_AVERAGE_SPEED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getAverageSpeed() {
    return averageSpeed;
  }


  @JsonProperty(JSON_PROPERTY_AVERAGE_SPEED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAverageSpeed(Double averageSpeed) {
    this.averageSpeed = averageSpeed;
  }


  public Options resultFormat(ResultFormat resultFormat) {
    this.resultFormat = resultFormat;
    return this;
  }

  /**
   * Get resultFormat
   * @return resultFormat
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RESULT_FORMAT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public ResultFormat getResultFormat() {
    return resultFormat;
  }


  @JsonProperty(JSON_PROPERTY_RESULT_FORMAT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setResultFormat(ResultFormat resultFormat) {
    this.resultFormat = resultFormat;
  }


  /**
   * Return true if this Options object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Options options = (Options) o;
    return Objects.equals(this.currency, options.currency) &&
        Objects.equals(this.startTime, options.startTime) &&
        Objects.equals(this.tollTime, options.tollTime) &&
        Objects.equals(this.duration, options.duration) &&
        Objects.equals(this.trafficMode, options.trafficMode) &&
        Objects.equals(this.detourFactor, options.detourFactor) &&
        Objects.equals(this.averageSpeed, options.averageSpeed) &&
        Objects.equals(this.resultFormat, options.resultFormat);
  }

  @Override
  public int hashCode() {
    return Objects.hash(currency, startTime, tollTime, duration, trafficMode, detourFactor, averageSpeed, resultFormat);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Options {\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    tollTime: ").append(toIndentedString(tollTime)).append("\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    trafficMode: ").append(toIndentedString(trafficMode)).append("\n");
    sb.append("    detourFactor: ").append(toIndentedString(detourFactor)).append("\n");
    sb.append("    averageSpeed: ").append(toIndentedString(averageSpeed)).append("\n");
    sb.append("    resultFormat: ").append(toIndentedString(resultFormat)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `currency` to the URL query string
    if (getCurrency() != null) {
      joiner.add(String.format("%scurrency%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getCurrency()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `startTime` to the URL query string
    if (getStartTime() != null) {
      joiner.add(String.format("%sstartTime%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getStartTime()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `tollTime` to the URL query string
    if (getTollTime() != null) {
      joiner.add(String.format("%stollTime%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getTollTime()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `duration` to the URL query string
    if (getDuration() != null) {
      joiner.add(String.format("%sduration%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getDuration()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `trafficMode` to the URL query string
    if (getTrafficMode() != null) {
      joiner.add(String.format("%strafficMode%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getTrafficMode()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `detourFactor` to the URL query string
    if (getDetourFactor() != null) {
      joiner.add(String.format("%sdetourFactor%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getDetourFactor()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `averageSpeed` to the URL query string
    if (getAverageSpeed() != null) {
      joiner.add(String.format("%saverageSpeed%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getAverageSpeed()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `resultFormat` to the URL query string
    if (getResultFormat() != null) {
      joiner.add(String.format("%sresultFormat%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getResultFormat()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    return joiner.toString();
  }
}

