/*
 * Matrix Routing
 * With the Matrix Routing service you can compute distances and travel times between a set of origins and destinations.
 *
 * The version of the OpenAPI document: 1.5
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.matrixrouting.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.matrixrouting.model.ResultFormat;
import com.ptvgroup.developer.client.matrixrouting.model.TrafficMode;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.time.OffsetDateTime;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * Options
 */
@JsonPropertyOrder({
  Options.JSON_PROPERTY_CURRENCY,
  Options.JSON_PROPERTY_START_TIME,
  Options.JSON_PROPERTY_TOLL_TIME,
  Options.JSON_PROPERTY_DURATION,
  Options.JSON_PROPERTY_TRAFFIC_MODE,
  Options.JSON_PROPERTY_RESULT_FORMAT
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-01-23T08:14:50.380230Z[Etc/UTC]")
public class Options {
  public static final String JSON_PROPERTY_CURRENCY = "currency";
  private JsonNullable<String> currency = JsonNullable.<String>undefined();

  public static final String JSON_PROPERTY_START_TIME = "startTime";
  private JsonNullable<OffsetDateTime> startTime = JsonNullable.<OffsetDateTime>undefined();

  public static final String JSON_PROPERTY_TOLL_TIME = "tollTime";
  private JsonNullable<OffsetDateTime> tollTime = JsonNullable.<OffsetDateTime>undefined();

  public static final String JSON_PROPERTY_DURATION = "duration";
  private Integer duration = 0;

  public static final String JSON_PROPERTY_TRAFFIC_MODE = "trafficMode";
  private TrafficMode trafficMode = TrafficMode.AVERAGE;

  public static final String JSON_PROPERTY_RESULT_FORMAT = "resultFormat";
  private ResultFormat resultFormat = ResultFormat.PLAIN;

  public Options() { 
  }

  public Options currency(String currency) {
    this.currency = JsonNullable.<String>of(currency);
    return this;
  }

   /**
   * Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**.
   * @return currency
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Currency to which the toll prices should be converted to. Use the currency code according to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). If it is not specified, the currency is taken from the **profile**.")
  @JsonIgnore

  public String getCurrency() {
        return currency.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_CURRENCY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<String> getCurrency_JsonNullable() {
    return currency;
  }
  
  @JsonProperty(JSON_PROPERTY_CURRENCY)
  public void setCurrency_JsonNullable(JsonNullable<String> currency) {
    this.currency = currency;
  }

  public void setCurrency(String currency) {
    this.currency = JsonNullable.<String>of(currency);
  }


  public Options startTime(OffsetDateTime startTime) {
    this.startTime = JsonNullable.<OffsetDateTime>of(startTime);
    return this;
  }

   /**
   * Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **tollTime**. If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./concepts/time-dependent-matrix) for more information on the relevance of date and time.
   * @return startTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2020-12-04T06:00Z", value = "Defines the start time of each route, formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This field is mutually exclusive with **tollTime**. If not specified, the routes are calculated using the average speed of each road. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.  If **duration** is also specified, the travel time profiles will be calculated using the horizon defined with **startTime** and **duration** See [here](./concepts/time-dependent-matrix) for more information on the relevance of date and time.")
  @JsonIgnore

  public OffsetDateTime getStartTime() {
        return startTime.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_START_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<OffsetDateTime> getStartTime_JsonNullable() {
    return startTime;
  }
  
  @JsonProperty(JSON_PROPERTY_START_TIME)
  public void setStartTime_JsonNullable(JsonNullable<OffsetDateTime> startTime) {
    this.startTime = startTime;
  }

  public void setStartTime(OffsetDateTime startTime) {
    this.startTime = JsonNullable.<OffsetDateTime>of(startTime);
  }


  public Options tollTime(OffsetDateTime tollTime) {
    this.tollTime = JsonNullable.<OffsetDateTime>of(tollTime);
    return this;
  }

   /**
   * Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with **startTime**. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/toll-matrix-calculation) for more information on the relevance of date and time.
   * @return tollTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Defines the date and time at which to calculate toll prices formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). This parameter only has an influence if toll related results are requested. It can only be used in combination with **trafficMode** _AVERAGE_  and it is mutually exclusive with **startTime**. If the date-time string does not include an explicit offset to UTC, the position of the **origins** are used to find the missing offset. If multiple offsets are detected then an error is returned and the distance matrix calculation is aborted totally.         The date must not be before 1970-01-01T00:00:00+00:00 nor after 2037-12-31T23:59:59+00:00.   See [here](./concepts/toll-matrix-calculation) for more information on the relevance of date and time.")
  @JsonIgnore

  public OffsetDateTime getTollTime() {
        return tollTime.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_TOLL_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<OffsetDateTime> getTollTime_JsonNullable() {
    return tollTime;
  }
  
  @JsonProperty(JSON_PROPERTY_TOLL_TIME)
  public void setTollTime_JsonNullable(JsonNullable<OffsetDateTime> tollTime) {
    this.tollTime = tollTime;
  }

  public void setTollTime(OffsetDateTime tollTime) {
    this.tollTime = JsonNullable.<OffsetDateTime>of(tollTime);
  }


  public Options duration(Integer duration) {
    this.duration = duration;
    return this;
  }

   /**
   * Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set.
   * minimum: 0
   * maximum: 86400
   * @return duration
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Defines the duration [s] for the calculation of travel time profiles. This field is ignored if **startTime** is not set.")
  @JsonProperty(JSON_PROPERTY_DURATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getDuration() {
    return duration;
  }


  @JsonProperty(JSON_PROPERTY_DURATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDuration(Integer duration) {
    this.duration = duration;
  }


  public Options trafficMode(TrafficMode trafficMode) {
    this.trafficMode = trafficMode;
    return this;
  }

   /**
   * Get trafficMode
   * @return trafficMode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_TRAFFIC_MODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public TrafficMode getTrafficMode() {
    return trafficMode;
  }


  @JsonProperty(JSON_PROPERTY_TRAFFIC_MODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTrafficMode(TrafficMode trafficMode) {
    this.trafficMode = trafficMode;
  }


  public Options resultFormat(ResultFormat resultFormat) {
    this.resultFormat = resultFormat;
    return this;
  }

   /**
   * Get resultFormat
   * @return resultFormat
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_RESULT_FORMAT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public ResultFormat getResultFormat() {
    return resultFormat;
  }


  @JsonProperty(JSON_PROPERTY_RESULT_FORMAT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setResultFormat(ResultFormat resultFormat) {
    this.resultFormat = resultFormat;
  }


  /**
   * Return true if this Options object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Options options = (Options) o;
    return equalsNullable(this.currency, options.currency) &&
        equalsNullable(this.startTime, options.startTime) &&
        equalsNullable(this.tollTime, options.tollTime) &&
        Objects.equals(this.duration, options.duration) &&
        Objects.equals(this.trafficMode, options.trafficMode) &&
        Objects.equals(this.resultFormat, options.resultFormat);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(hashCodeNullable(currency), hashCodeNullable(startTime), hashCodeNullable(tollTime), duration, trafficMode, resultFormat);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Options {\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    tollTime: ").append(toIndentedString(tollTime)).append("\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    trafficMode: ").append(toIndentedString(trafficMode)).append("\n");
    sb.append("    resultFormat: ").append(toIndentedString(resultFormat)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

